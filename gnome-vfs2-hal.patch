? =0.2.98
? gnome-vfs-new-hal-patch-and-eject-fixes.patch
? imported/Makefile
? imported/Makefile.in
? imported/neon/Makefile.in
? libgnomevfs/s-enum-types-c
? libgnomevfs/s-enum-types-h
? test/test-dns-sd
? test/test-mime-info-cache
Index: configure.in
===================================================================
RCS file: /cvs/gnome/gnome-vfs/configure.in,v
retrieving revision 1.342
diff -u -p -r1.342 configure.in
--- configure.in	22 Sep 2004 08:38:38 -0000	1.342
+++ configure.in	24 Sep 2004 22:50:32 -0000
@@ -697,8 +697,8 @@ esac],
 [ENABLE_HAL=no]) dnl Default value
 
 if test "x$ENABLE_HAL" = "xyes"; then
-	PKG_CHECK_MODULES(HAL, hal >= 0.2.92,
-		[ USE_HAL="hal >= 0.2.92, dbus-1 >= 0.22, dbus-glib-1 >= 0.22"; AC_DEFINE(USE_HAL, 1, [defined if using libhal])],
+	PKG_CHECK_MODULES(HAL, hal >= 0.2.98,
+		[ USE_HAL="hal >= 0.2.98, hal-storage >= 0.2.98, dbus-1 >= 0.22, dbus-glib-1 >= 0.22"; AC_DEFINE(USE_HAL, 1, [defined if using libhal])],
 		[ USE_HAL=""])
 else
 	USE_HAL=""
Index: libgnomevfs/GNOME_VFS_Daemon.idl
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/GNOME_VFS_Daemon.idl,v
retrieving revision 1.9
diff -u -p -r1.9 GNOME_VFS_Daemon.idl
--- libgnomevfs/GNOME_VFS_Daemon.idl	15 Jul 2004 13:21:15 -0000	1.9
+++ libgnomevfs/GNOME_VFS_Daemon.idl	24 Sep 2004 22:50:33 -0000
@@ -63,6 +63,7 @@ module GNOME {
 			boolean is_user_visible;
 			boolean is_connected;
 		        string hal_udi;
+			boolean should_eject;
 		};
 		
 		typedef sequence<Drive> DriveList;
Index: libgnomevfs/gnome-vfs-drive.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-drive.c,v
retrieving revision 1.8
diff -u -p -r1.8 gnome-vfs-drive.c
--- libgnomevfs/gnome-vfs-drive.c	16 Aug 2004 08:44:06 -0000	1.8
+++ libgnomevfs/gnome-vfs-drive.c	24 Sep 2004 22:50:33 -0000
@@ -582,6 +582,8 @@ gnome_vfs_drive_to_corba (GnomeVFSDrive 
 	
 	corba_drive->is_user_visible = drive->priv->is_user_visible;
 	corba_drive->is_connected = drive->priv->is_connected;
+
+	corba_drive->should_eject = drive->priv->should_eject;
 }
 
 GnomeVFSDrive *
@@ -617,5 +619,6 @@ _gnome_vfs_drive_from_corba (const GNOME
 	drive->priv->is_user_visible = corba_drive->is_user_visible;
 	drive->priv->is_connected = corba_drive->is_connected;
 
+	drive->priv->should_eject = corba_drive->should_eject;
 	return drive;
 }
Index: libgnomevfs/gnome-vfs-hal-mounts.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-hal-mounts.c,v
retrieving revision 1.7
diff -u -p -r1.7 gnome-vfs-hal-mounts.c
--- libgnomevfs/gnome-vfs-hal-mounts.c	19 Aug 2004 07:34:01 -0000	1.7
+++ libgnomevfs/gnome-vfs-hal-mounts.c	24 Sep 2004 22:50:33 -0000
@@ -1,7 +1,7 @@
 /* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
 /* gnome-vfs-hal-mounts.c - read and monitor volumes using freedesktop HAL
 
-   Copyright (C) 2004 David Zeuthen
+   Copyright (C) 2004 Red Hat, Inc
 
    The Gnome Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public License as
@@ -18,7 +18,7 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
 
-   Author: David Zeuthen <david@fubar.dk>
+   Author: David Zeuthen <davidz@redhat.com>
 */
 
 #include <config.h>
@@ -39,6 +39,7 @@
 #include <libgnomevfs/gnome-vfs-i18n.h>
 
 #include <libhal.h>
+#include <libhal-storage.h>
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 
@@ -47,1322 +48,549 @@
 #include "gnome-vfs-volume-monitor-daemon.h"
 #include "gnome-vfs-volume-monitor-private.h"
 
-/** Use HAL to retrieve information about drives and volumes.
- *
- *  TODO/QUESTIONS/ISSUES
- *
- *  - Fix HAL so hal_initialize() fails when we cannot connect to the HAL
- *    daemon; When this works GNOME VFS falls back to mtab/fstab monitoring.
- *    Which is nice.
- *
- *  - When a recordable disc (CD-R, CD-RW, DVD-R, DVD+RW etc.) is closed
- *    should we map down to the non-cdrecordable type? E.g. 
- *
- *                                 CD-R, CD-RW   |->   CD-ROM
- *       DVD-R, DVD-RW, DVD+R, DVD+RW, DVD-RAM   |->   DVD-ROM
- *
- *    Currently we don't do this. One reason for doing this is that consumers
- *    might download e.g. a Linux distrobution and burn the ISO's, close the
- *    disc and then it's a CD-ROM since they can't burn to the disc more
- *    anyway? Maybe we should do this, but not for RW discs, e.g. only
- *
- *                        CD-R   |->   CD-ROM
- *                DVD-R, DVD+R   |->   DVD-ROM
- *
- *    when closed; this I think would make sense. Comments?
- *
- *  - When libgphoto2 is completely halificated, get the GNOME VFS backend
- *    to work and add functionality (in this file) to show a camera icon that
- *    links to the appropriate GNOME VFS URI. (when the camera is not 
- *    usb-storage based of course)
- *
- *  - Do the same for MP3 players when GNOME VFS backends for these emerge.
- *
- *  NOTE
- *
- *  - For this patch you need a recent version of GNOME VFS that doesn't
- *    crash when a name contains a '/' character
- */
-
-
-/* If this is defined then only mounted volumes are shown which gives
- *  a Mac OS X like experience. Otherwise unmounted volumes are shown
- *  as a drive icon. Obviously, this requires an automounter like
- *  gnome-volume-manager.
- */
-/*#define HAL_ONLY_SHOW_MOUNTED_VOLUMES*/
-
-/* If this is defined use the standard icons available. Otherwise new
- *  a new, more fine grained icon set is used. See below..
- *
- */
-/*#define HAL_USE_STOCK_ICONS*/
-
-
-#ifdef HAL_USE_STOCK_ICONS
-
-#define HAL_ICON_DRIVE_REMOVABLE          "gnome-dev-removable"
-#define HAL_ICON_DRIVE_REMOVABLE_USB      "gnome-dev-removable"
-#define HAL_ICON_DRIVE_REMOVABLE_IEEE1394 "gnome-dev-removable"
-#define HAL_ICON_DISC_CDROM               "gnome-dev-cdrom"
-#define HAL_ICON_DISC_CDR                 "gnome-dev-cdrom"
-#define HAL_ICON_DISC_CDRW                "gnome-dev-cdrom"
-#define HAL_ICON_DISC_DVDROM              "gnome-dev-cdrom"
-#define HAL_ICON_DISC_DVDRAM              "gnome-dev-cdrom"
-#define HAL_ICON_DISC_DVDR                "gnome-dev-cdrom"
-#define HAL_ICON_DISC_DVDRW               "gnome-dev-cdrom"
-#define HAL_ICON_DISC_DVDRW_PLUS          "gnome-dev-cdrom"
-#define HAL_ICON_DISC_DVDR_PLUS           "gnome-dev-cdrom"
-#define HAL_ICON_MEDIA_COMPACT_FLASH      "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_MEMORY_STICK       "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_SMART_MEDIA        "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_SD_MMC             "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_FLOPPY             "gnome-dev-floppy"
-#define HAL_ICON_MEDIA_HARDDISK           "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_HARDDISK_USB       "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_HARDDISK_IEEE1394  "gnome-dev-harddisk"
-#define HAL_ICON_PORTABLE_AUDIO_PLAYER    "gnome-dev-harddisk"
-#define HAL_ICON_CAMERA                   "gnome-dev-harddisk"
-
-#else
-
-#define HAL_ICON_DRIVE_REMOVABLE          "gnome-dev-removable"
-#define HAL_ICON_DRIVE_REMOVABLE_USB      "gnome-dev-removable-usb"
-#define HAL_ICON_DRIVE_REMOVABLE_IEEE1394 "gnome-dev-removable-ieee1394"
-#define HAL_ICON_DISC_CDROM               "gnome-dev-cdrom"
-#define HAL_ICON_DISC_CDR                 "gnome-dev-disc-cdr"
-#define HAL_ICON_DISC_CDRW                "gnome-dev-disc-cdrw"
-#define HAL_ICON_DISC_DVDROM              "gnome-dev-disc-dvdrom"
-#define HAL_ICON_DISC_DVDRAM              "gnome-dev-disc-dvdram"
-#define HAL_ICON_DISC_DVDR                "gnome-dev-disc-dvdr"
-#define HAL_ICON_DISC_DVDRW               "gnome-dev-disc-dvdrw"
-#define HAL_ICON_DISC_DVDRW_PLUS          "gnome-dev-disc-dvdrw-plus"
-#define HAL_ICON_DISC_DVDR_PLUS           "gnome-dev-disc-dvdr-plus"
-#define HAL_ICON_MEDIA_COMPACT_FLASH      "gnome-dev-media-cf"
-#define HAL_ICON_MEDIA_MEMORY_STICK       "gnome-dev-media-ms"
-#define HAL_ICON_MEDIA_SMART_MEDIA        "gnome-dev-media-sm"
-#define HAL_ICON_MEDIA_SD_MMC             "gnome-dev-media-sdmmc"
-#define HAL_ICON_MEDIA_FLOPPY             "gnome-dev-floppy"
-#define HAL_ICON_MEDIA_HARDDISK           "gnome-dev-harddisk"
-#define HAL_ICON_MEDIA_HARDDISK_USB       "gnome-dev-harddisk-usb"
-#define HAL_ICON_MEDIA_HARDDISK_IEEE1394  "gnome-dev-harddisk-ieee1394"
-#define HAL_ICON_PORTABLE_AUDIO_PLAYER    "gnome-dev-portable-audio-player"
-#define HAL_ICON_CAMERA                   "gnome-dev-camera"
-
-#endif /* HAL_USE_STOCK_ICONS */
-
-typedef struct {
-	char *udi;
-
-	int device_major;
-	int device_minor;
-	char *device_file;
-
-	char *bus;                /* ide, scsi, usb, ieee1394, ... */
-	char *vendor;             /* may be NULL, is never "" */
-	char *model;              /* may be NULL, is never "" */
-	gboolean is_hotpluggable;
-	gboolean is_removable;
-	gboolean no_partitions;
-	char *type;               /* disk, cdrom, floppy, compact_flash, 
-				   * memory_stick, smart_media, sd_mmc, ... */
-
-	char *physical_device;  /* UDI of physical device, e.g. the 
-				 * IDE, USB, IEEE1394 device */
-
-} GnomeVFSHalDrive;
-
 typedef struct {
-	char *udi;
-
-	int device_major;
-	int device_minor;
-	char *device_file;
-	char *volume_label; /* may be NULL, is never "" */
-	gboolean is_mounted;
-	char *mount_point;  /* NULL iff !is_mounted */
-	char *fstype;       /* NULL iff !is_mounted or unknown */
-
-	gboolean is_disc;
-	char *disc_type;    /* NULL iff !is_disc */
-	gboolean disc_has_audio;
-	gboolean disc_has_data;
-	gboolean disc_is_appendable;
-	gboolean disc_is_blank;
-	gboolean disc_is_rewritable;
-} GnomeVFSHalVolume;
-
-static void
-_hal_free_drive (GnomeVFSHalDrive *drive)
-{
-	if (drive == NULL )
-		return;
-
-	free (drive->udi);
-	hal_free_string (drive->device_file);
-	hal_free_string (drive->bus);
-	hal_free_string (drive->vendor);
-	hal_free_string (drive->model);
-	hal_free_string (drive->type);
-}
-
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	HalStoragePolicy *hal_storage_policy;
+} GnomeVFSHalUserData;
 
 static void
-_hal_free_vol (GnomeVFSHalVolume *vol)
+_hal_mainloop_integration (LibHalContext *ctx, 
+			   DBusConnection * dbus_connection)
 {
-	if (vol == NULL )
-		return;
-
-	free (vol->udi);
-	hal_free_string (vol->device_file);
-	hal_free_string (vol->volume_label);
-	hal_free_string (vol->fstype);
-	hal_free_string (vol->mount_point);
-	hal_free_string (vol->disc_type);
+        dbus_connection_setup_with_g_main (dbus_connection, NULL);
 }
 
-
-/* Given a UDI for a HAL device of capability 'storage', this
- *  function retrieves all the relevant properties into a convenient
- *  structure.  Returns NULL if UDI is invalid or device is not of
- *  capability 'storage'.
- *
- *  Free with _hal_free_drive().
- */
-static GnomeVFSHalDrive *
-_hal_get_drive (const char *udi, LibHalContext *hal_ctx)
+static void 
+_hal_device_added (LibHalContext *hal_ctx, 
+		   const char *udi)
 {
-	GnomeVFSHalDrive *drive;
-
-	drive = g_new0 (GnomeVFSHalDrive, 1);
-	if (drive == NULL)
-		goto error;
-
-	drive->udi = strdup (udi);
-	if (drive->udi == NULL)
-		goto error;
-
-	drive->device_file = hal_device_get_property_string (
-		hal_ctx, udi, "block.device");
-	if (drive->device_file == NULL)
-		goto error;
-
-	drive->bus = hal_device_get_property_string (
-		hal_ctx, udi, "storage.bus");
-	if (drive->bus == NULL)
-		goto error;
-
-	drive->vendor = hal_device_get_property_string (
-		hal_ctx, udi, "storage.vendor");
-	if (drive->vendor == NULL)
-		goto error;
-
-	drive->model = hal_device_get_property_string (
-		hal_ctx, udi, "storage.model");
-	if (drive->model == NULL)
-		goto error;
-
-	drive->type = hal_device_get_property_string (
-		hal_ctx, udi, "storage.drive_type");
-	if (drive->type == NULL)
-		goto error;
+	GnomeVFSHalUserData *hal_userdata;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
 	
-	drive->is_hotpluggable = hal_device_get_property_bool (
-		hal_ctx, udi, "storage.hotpluggable");
-
-	drive->is_removable = hal_device_get_property_bool (
-		hal_ctx, udi, "storage.removable");
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	volume_monitor_daemon = hal_userdata->volume_monitor_daemon;
 
-	drive->no_partitions = hal_device_get_property_bool (
-		hal_ctx, udi, "block.no_partitions");
+	/* Handle optical discs without data since these are not handled
+	 * by GNOME VFS
+	 */
+	if (hal_device_get_property_bool (hal_ctx, udi, "volume.is_disc")) {
+		const char *storage_udi;
 
-	drive->physical_device = hal_device_get_property_string (
-		hal_ctx, udi, "storage.physical_device");
-	if (drive->physical_device == NULL)
-		goto error;
-
-	return drive;
-error:
-	_hal_free_drive (drive);
-	return NULL;
+		storage_udi = hal_device_get_property_string (hal_ctx, udi, "block.storage_device");
+		if (storage_udi != NULL) {
+			GnomeVFSDrive *drive;
+
+			drive = _gnome_vfs_volume_monitor_find_drive_by_hal_udi (
+				GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), storage_udi);
+			if (drive != NULL) {
+				/* this function also handles optical discs without data */
+				_gnome_vfs_hal_mounts_modify_drive (volume_monitor_daemon, drive);
+			}
+		}		
+	}
 }
 
-/* Given a UDI for a HAL device of capability 'volume', this function
- *  retrieves all the relevant properties into a convenient structure.
- *  Returns NULL if UDI is invalid or device is not of capability
- *  'volume'.
- *
- *  Free with _hal_free_vol().
- */
-static GnomeVFSHalVolume *
-_hal_get_vol (const char *udi, LibHalContext *hal_ctx)
+static void 
+_hal_device_removed (LibHalContext *hal_ctx, const char *udi)
 {
-	GnomeVFSHalVolume *vol;
-
-	vol = g_new0 (GnomeVFSHalVolume, 1);
-	if (vol == NULL)
-		goto error;
-
-	/* only care about capability volume */
-	if (!hal_device_query_capability (
-		    hal_ctx,
-		    udi, "volume"))
-		goto error;
-
-	vol->udi = strdup (udi);
-	if (vol->udi == NULL)
-		goto error;
-
-	vol->device_major = hal_device_get_property_int (
-		hal_ctx, udi, "block.major");
-
-	vol->device_minor = hal_device_get_property_int (
-		hal_ctx, udi, "block.minor");
-
-	vol->device_file = hal_device_get_property_string (
-		hal_ctx,
-		udi, "block.device");
-	if (vol->device_file == NULL)
-		goto error;
-
-	if (hal_device_property_exists (
-		    hal_ctx,
-		    udi, "volume.label")) {
-		vol->volume_label = hal_device_get_property_string (
-			hal_ctx,
-			udi, "volume.label");
-		if (strlen (vol->volume_label) == 0) {
-			hal_free_string (vol->volume_label);
-			vol->volume_label = NULL;
-		}
-	}
+	GnomeVFSDrive *drive;
+	GnomeVFSVolume *volume;
+	GnomeVFSHalUserData *hal_userdata;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	volume_monitor_daemon = hal_userdata->volume_monitor_daemon;
 
+	drive = _gnome_vfs_volume_monitor_find_drive_by_hal_udi (
+		GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), udi);
 
-	vol->is_mounted = hal_device_get_property_bool (
-		hal_ctx,
-		udi, "volume.is_mounted");
-			    
-	if (vol->is_mounted) {
-		vol->mount_point = hal_device_get_property_string (
-			hal_ctx,
-			udi, "volume.mount_point");
-		if (vol->mount_point == NULL || strlen (vol->mount_point) == 0)
-			goto error;
-		
-	}
+	volume = _gnome_vfs_volume_monitor_find_volume_by_hal_udi (
+		GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), udi);
 
-	vol->fstype = hal_device_get_property_string (
-		hal_ctx,
-		udi, "volume.fstype");
-	if (vol->fstype == NULL)
-		goto error;
-	if (strlen(vol->fstype) == 0) {
-		hal_free_string (vol->fstype);
-		vol->fstype = NULL;
+	/* Just remove the drive and or volume here; will also be done in 
+	 * update_mtab_volumes and update_fstab_drives in the source file 
+	 * gnome-vfs-volume-monitor-daemon.c but that wont matter much.
+	 *
+	 * We need to do this to handle optical discs without data since these
+	 * are not handled by GNOME VFS
+	 */
+	if (drive != NULL) {
+		_gnome_vfs_volume_monitor_disconnected (GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), drive);
 	}
 
-	/* optical disc properties */
-	if (hal_device_get_property_bool (hal_ctx,
-					  udi, "volume.is_disc")) {
-		vol->is_disc = TRUE;
-
-		vol->disc_type = hal_device_get_property_string (
-			hal_ctx,
-			udi, "volume.disc.type");
-		if (vol->disc_type == NULL || strlen (vol->disc_type) == 0)
-			goto error;
-
-		vol->disc_has_audio = hal_device_get_property_bool (
-			hal_ctx,
-			udi, "volume.disc.has_audio");
-		vol->disc_has_data = hal_device_get_property_bool (
-			hal_ctx,
-			udi, "volume.disc.has_data");
-		vol->disc_is_appendable = hal_device_get_property_bool (
-			hal_ctx,
-			udi, "volume.disc.is_appendable");
-		vol->disc_is_blank = hal_device_get_property_bool (
-			hal_ctx,
-			udi, "volume.disc.is_blank");
-		vol->disc_is_rewritable = hal_device_get_property_bool (
-			hal_ctx,
-			udi, "volume.disc.is_rewritable");
+	if (volume != NULL) {
+		_gnome_vfs_volume_monitor_unmounted (GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), volume);
 	}
-
-
-
-	return vol;
-
-error:
-	_hal_free_vol (vol);
-	return NULL;
 }
 
-/** Get the GnomeVFSHalDrive from a GnomeVFSHalVolume. Returns NULL on error.
- *
- *  Free with _hal_free_drive().
- */
-static GnomeVFSHalDrive *
-_hal_get_drive_from_vol (GnomeVFSHalVolume *vol, LibHalContext *hal_ctx)
+static void 
+_hal_device_new_capability (LibHalContext *hal_ctx, 
+			    const char *udi, 
+			    const char *capability)
 {
-	const char *storage_udi;
-
-	storage_udi = hal_device_get_property_string (
-		hal_ctx, vol->udi, "block.storage_device");	
-	if (storage_udi == NULL)
-		goto error;
-
-	return _hal_get_drive (storage_udi, hal_ctx);
-error:
-	return NULL;
-}
-
-
-
-/***********************************************************************/
+	GnomeVFSHalUserData *hal_userdata;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	volume_monitor_daemon = hal_userdata->volume_monitor_daemon;
 
-/** If you don't have a recent GNOME VFS you need to uncomment the code
- *  below
- *
- *  OLD ERROR: Fixup the name given to GnomeVFS, it may not contain
- *  '/'-characters.  Substitute these with '-'.
- */
-static void
-fixup_name (char *name)
-{
-	;
-	/* 
-	int i;
-
-	for (i=0; name[i]!='\0'; i++) {
-		if (name[i] == '/')
-			name[i] = '-';
-	}
-	*/
+	/* do nothing */
 }
 
-/***********************************************************************/
-
-static char *_hal_get_vol_name (GnomeVFSHalVolume *vol, 
-				GnomeVFSHalDrive *drive, 
-				LibHalContext *hal_ctx);
-static char *_hal_get_vol_icon (GnomeVFSHalVolume *vol, 
-				GnomeVFSHalDrive *drive, 
-				LibHalContext *hal_ctx);
-static int _hal_get_vol_type (GnomeVFSHalVolume *vol, 
-			      GnomeVFSHalDrive *drive, 
-			      LibHalContext *hal_ctx);
-
-
-
-/* vol may be NULL */
-static char *
-_hal_get_drive_name (GnomeVFSHalVolume *vol, GnomeVFSHalDrive *drive, 
-		     LibHalContext *hal_ctx)
+static void 
+_hal_device_lost_capability (LibHalContext *hal_ctx, 
+			     const char *udi,
+			     const char *capability)
 {
-	char *name;
-
-
-#ifdef HAL_ONLY_SHOW_MOUNTED_VOLUMES
-	/* this is safe, as drives and volumes are 1:1 */
-	if (vol != NULL)
-		return _hal_get_vol_name (vol, drive, hal_ctx);
-#else
-	/* Bork, storage.removable is a bit broken on HAL (I fear only
-	 * .fdi files will fix it), so it's not sane to rely on this..
-	 * Which is bad, because without computer:/// looks ugly, e.g.
-	 * "<drive_name> : <volume_name>" even for storage that is
-	 * not removable. Bork.
-	 */
-
-        /*
-	if (vol != NULL && !drive->is_removable)
-		return _hal_get_vol_name (vol, drive, hal_ctx);
-	*/
-#endif
-
-	if (strcmp (drive->type, "cdrom") == 0) {
-		gboolean cdr;
-		gboolean cdrw;
-		gboolean dvd;
-		gboolean dvdplusr;
-		gboolean dvdplusrw;
-		gboolean dvdr;
-		gboolean dvdram;
-		char *first;
-		char *second;
-
-		/* use the capabilities of the optical device */
-
-		cdr = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.cdr");
-		cdrw = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.cdrw");
-		dvd = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.dvd");
-		dvdplusr = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.dvdplusr");
-		dvdplusrw = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.dvdplusrw");
-		dvdr = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.dvdr");
-		dvdram = hal_device_get_property_bool (
-			hal_ctx, drive->udi, "storage.cdrom.dvdram");
-
-		first = "CD-ROM";
-		if( cdr )
-			first = "CD-R";
-		if( cdrw )
-			first = "CD-RW";
-
-		/* Hmm, '/' is not an allowed character, so use '\' instead 
-		 *
-		 * TODO: Fix this
-		 */
-		second = "";
-		if( dvd )
-			second = "/DVD-ROM";
-		if( dvdplusr )
-			second = "/DVD+R";
-		if( dvdplusrw )
-			second = "/DVD+RW";
-		if( dvdr )
-			second = "/DVD-R";
-		if( dvdram )
-			second = "/DVD-RAM";
-		if( dvdplusr && dvdr )
-			second = "/DVD\302\261R";
-		if( dvdplusr && dvdplusrw && dvdr )
-			second = "/DVD\302\261RW";
-
-		name = g_strdup_printf ("%s%s", first, second);
-	} else if (strcmp (drive->type, "floppy") == 0) {
-		/* TODO: Check for LS120 or Zip drive etc. */
-		name = g_strdup ("Floppy Drive");
-	} else {
-		name = g_strdup (drive->model);
-	}
-
-	fixup_name (name);
+	GnomeVFSHalUserData *hal_userdata;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	volume_monitor_daemon = hal_userdata->volume_monitor_daemon;
 
-	return name;
+	/* do nothing */
 }
 
-/* vol may be NULL */
-static char *
-_hal_get_drive_icon (GnomeVFSHalVolume *vol, GnomeVFSHalDrive *drive, 
-		     LibHalContext *hal_ctx)
+static void 
+_hal_device_property_modified (LibHalContext *hal_ctx, 
+			       const char *udi,
+			       const char *key,
+			       dbus_bool_t is_removed,
+			       dbus_bool_t is_added)
 {
-	char *name;
-
-	if (strcmp (drive->bus, "usb") == 0) {
-		name = g_strdup (HAL_ICON_DRIVE_REMOVABLE_USB);
-	} else if (strcmp (drive->bus, "ieee1394") == 0) {
-		name = g_strdup (HAL_ICON_DRIVE_REMOVABLE_IEEE1394);
-	} else {
-		name = g_strdup (HAL_ICON_DRIVE_REMOVABLE);
-	}
+	GnomeVFSHalUserData *hal_userdata;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	volume_monitor_daemon = hal_userdata->volume_monitor_daemon;
 
-	return name;
+	/* do nothing */
 }
 
-/* vol may be NULL */
-static int
-_hal_get_drive_type (GnomeVFSHalVolume *vol, GnomeVFSHalDrive *drive, 
-		     LibHalContext *hal_ctx)
+static void 
+_hal_device_condition (LibHalContext *hal_ctx, 
+		       const char *udi,
+		       const char *condition_name,
+		       DBusMessage *message)
 {
-	int type;
-
-	type = GNOME_VFS_DEVICE_TYPE_HARDDRIVE;
-
-	if (strcmp (drive->type, "cdrom") == 0)
-		type = GNOME_VFS_DEVICE_TYPE_CDROM;
-	if (strcmp (drive->type, "floppy") == 0)
-		type = GNOME_VFS_DEVICE_TYPE_FLOPPY;
-	else if (strcmp (drive->type, "compact_flash") == 0 ||
-		 strcmp (drive->type, "memory_stick") == 0 ||
-		 strcmp (drive->type, "smart_media") == 0 ||
-		 strcmp (drive->type, "sd_mmc") == 0)
-		type = GNOME_VFS_DEVICE_TYPE_MEMORY_STICK;
+	GnomeVFSHalUserData *hal_userdata;
+	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
+	
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	volume_monitor_daemon = hal_userdata->volume_monitor_daemon;
 
-	return type;
+	/* do nothing */
 }
 
+static LibHalFunctions
+hal_functions = { _hal_mainloop_integration,
+		  _hal_device_added,
+		  _hal_device_removed,
+		  _hal_device_new_capability,
+		  _hal_device_lost_capability,
+		  _hal_device_property_modified,
+		  _hal_device_condition };
 
+static HalStoragePolicyIconPair icon_mapping[] = {
+	{HAL_STORAGE_ICON_DRIVE_REMOVABLE_DISK,           "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_REMOVABLE_DISK_IDE,       "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_REMOVABLE_DISK_SCSI,      "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_REMOVABLE_DISK_USB,       "gnome-dev-removable-usb"},
+	{HAL_STORAGE_ICON_DRIVE_REMOVABLE_DISK_IEEE1394,  "gnome-dev-removable-1394"},
+	{HAL_STORAGE_ICON_DRIVE_DISK,                     "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_DISK_IDE,                 "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_DISK_SCSI,                "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_DISK_USB,                 "gnome-dev-removable-usb"},
+	{HAL_STORAGE_ICON_DRIVE_DISK_IEEE1394,            "gnome-dev-removable-1394"},
+	{HAL_STORAGE_ICON_DRIVE_CDROM,                    "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_CDROM_IDE,                "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_CDROM_SCSI,               "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_CDROM_USB,                "gnome-dev-removable-usb"},
+	{HAL_STORAGE_ICON_DRIVE_CDROM_IEEE1394,           "gnome-dev-removable-1394"},
+	{HAL_STORAGE_ICON_DRIVE_FLOPPY,                   "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_FLOPPY_IDE,               "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_FLOPPY_SCSI,              "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_FLOPPY_USB,               "gnome-dev-removable-usb"},
+	{HAL_STORAGE_ICON_DRIVE_FLOPPY_IEEE1394,          "gnome-dev-removable-1394"},
+	{HAL_STORAGE_ICON_DRIVE_TAPE,                     "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_COMPACT_FLASH,            "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_MEMORY_STICK,             "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_SMART_MEDIA,              "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_SD_MMC,                   "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_CAMERA,                   "gnome-dev-removable"},
+	{HAL_STORAGE_ICON_DRIVE_PORTABLE_AUDIO_PLAYER,    "gnome-dev-removable"},
+
+	{HAL_STORAGE_ICON_VOLUME_REMOVABLE_DISK,          "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_REMOVABLE_DISK_IDE,      "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_REMOVABLE_DISK_SCSI,     "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_REMOVABLE_DISK_USB,      "gnome-dev-harddisk-usb"},
+	{HAL_STORAGE_ICON_VOLUME_REMOVABLE_DISK_IEEE1394, "gnome-dev-harddisk-1394"},
+	{HAL_STORAGE_ICON_VOLUME_DISK,                    "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_DISK_IDE,                "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_DISK_SCSI,               "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_DISK_USB,                "gnome-dev-harddisk-usb"},
+	{HAL_STORAGE_ICON_VOLUME_DISK_IEEE1394,           "gnome-dev-harddisk-1394"},
+	{HAL_STORAGE_ICON_VOLUME_CDROM,                   "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_VOLUME_CDROM_IDE,               "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_VOLUME_CDROM_SCSI,              "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_VOLUME_CDROM_USB,               "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_VOLUME_CDROM_IEEE1394,          "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_VOLUME_FLOPPY,                  "gnome-dev-floppy"},
+	{HAL_STORAGE_ICON_VOLUME_FLOPPY_IDE,              "gnome-dev-floppy"},
+	{HAL_STORAGE_ICON_VOLUME_FLOPPY_SCSI,             "gnome-dev-floppy"},
+	{HAL_STORAGE_ICON_VOLUME_FLOPPY_USB,              "gnome-dev-floppy"},
+	{HAL_STORAGE_ICON_VOLUME_FLOPPY_IEEE1394,         "gnome-dev-floppy"},
+	{HAL_STORAGE_ICON_VOLUME_TAPE,                    "gnome-dev-harddisk"},
+	{HAL_STORAGE_ICON_VOLUME_COMPACT_FLASH,           "gnome-dev-media-cf"},
+	{HAL_STORAGE_ICON_VOLUME_MEMORY_STICK,            "gnome-dev-media-ms"},
+	{HAL_STORAGE_ICON_VOLUME_SMART_MEDIA,             "gnome-dev-media-sm"},
+	{HAL_STORAGE_ICON_VOLUME_SD_MMC,                  "gnome-dev-media-sdmmc"},
+	{HAL_STORAGE_ICON_VOLUME_CAMERA,                  "camera"},
+	{HAL_STORAGE_ICON_VOLUME_PORTABLE_AUDIO_PLAYER,   "gnome-dev-ipod"},
+
+	{HAL_STORAGE_ICON_DISC_CDROM,                     "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_DISC_CDR,                       "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_DISC_CDRW,                      "gnome-dev-cdrom"},
+	{HAL_STORAGE_ICON_DISC_DVDROM,                    "gnome-dev-dvd"},
+	{HAL_STORAGE_ICON_DISC_DVDRAM,                    "gnome-dev-dvd"},
+	{HAL_STORAGE_ICON_DISC_DVDR,                      "gnome-dev-dvd"},
+	{HAL_STORAGE_ICON_DISC_DVDRW,                     "gnome-dev-dvd"},
+	{HAL_STORAGE_ICON_DISC_DVDPLUSR,                  "gnome-dev-dvd"},
+	{HAL_STORAGE_ICON_DISC_DVDPLUSRW,                 "gnome-dev-dvd"},
+
+/*
+	{HAL_STORAGE_ICON_DISC_CDROM,                     "gnome-dev-disc-cdrom"},
+	{HAL_STORAGE_ICON_DISC_CDR,                       "gnome-dev-disc-cdr"},
+	{HAL_STORAGE_ICON_DISC_CDRW,                      "gnome-dev-disc-cdrw"},
+	{HAL_STORAGE_ICON_DISC_DVDROM,                    "gnome-dev-disc-dvdrom"},
+	{HAL_STORAGE_ICON_DISC_DVDRAM,                    "gnome-dev-disc-dvdram"},
+	{HAL_STORAGE_ICON_DISC_DVDR,                      "gnome-dev-disc-dvdr"},
+	{HAL_STORAGE_ICON_DISC_DVDRW,                     "gnome-dev-disc-dvdrw"},
+	{HAL_STORAGE_ICON_DISC_DVDPLUSR,                  "gnome-dev-disc-dvdr-plus"},
+	{HAL_STORAGE_ICON_DISC_DVDPLUSRW,                 "gnome-dev-disc-dvdrw-plus"},
+*/
 
-/***********************************************************************/
-
-static char *
-_hal_get_vol_name (GnomeVFSHalVolume *vol, GnomeVFSHalDrive *drive, 
-		   LibHalContext *hal_ctx)
-{
-	char *name;
-
-	name = NULL;
-	if (vol->volume_label != NULL ) {
-
-		/* Using the label is the best thing */
-		name = g_strdup (vol->volume_label);
-
-	} else if (strcmp (drive->type, "cdrom") == 0) {
-
-		/* If it's a optical disc, use the disc type */
-		if (strcmp (vol->disc_type, "cd_rom") == 0) {
-			name = g_strdup (_("CD-ROM Disc"));
-		} else if (strcmp (vol->disc_type, "cd_r") == 0) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank CD-R Disc"));
-			else
-				name = g_strdup (_("CD-R Disc"));
-		} else if (strcmp (vol->disc_type, "cd_rw") == 0) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank CD-RW Disc"));
-			else
-				name = g_strdup (_("CD-RW Disc"));
-		} else if (strcmp (vol->disc_type, "dvd_rom") == 0) {
-					name = g_strdup (_("DVD-ROM Disc"));
-		} else if (strcmp (vol->disc_type, "dvd_r") == 0) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank DVD-R Disc"));
-			else
-				name = g_strdup (_("DVD-R Disc"));
-		} else if (strcmp (vol->disc_type, "dvd_ram") == 0) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank DVD-RAM Disc"));
-			else
-				name = g_strdup (_("DVD-RAM Disc"));
-		} else if ((strcmp (vol->disc_type, "dvd_rw_restricted_overwrite") == 0) || (strcmp (vol->disc_type, "dvd_rw") == 0)) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank DVD-RW Disc"));
-			else
-				name = g_strdup (_("DVD-RW Disc"));
-		} else if (strcmp (vol->disc_type, "dvd_plus_rw") == 0) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank DVD+RW Disc"));
-			else
-				name = g_strdup (_("DVD+RW Disc"));
-		} else if (strcmp (vol->disc_type, "dvdplusr") == 0) {
-			if (vol->disc_is_blank)
-				name = g_strdup (_("Blank DVD+R Disc"));
-			else
-				name = g_strdup (_("DVD+R Disc"));
-		} else {
-			name = g_strdup (_("Optical Disc"));
-		}
-
-		/* Special case for pure audio disc */
-		if (vol->disc_has_audio && !vol->disc_has_data) {
-			g_free (name);
-			name = g_strdup (_("Audio Disc"));
-		}
-
-	} else if (strcmp (drive->type, "compact_flash") == 0) {
-		name = g_strdup (_("Compact Flash Media"));
-	} else if (strcmp (drive->type, "memory_stick") == 0) {
-		name = g_strdup (_("Memory Stick Media"));
-	} else if (strcmp (drive->type, "smart_media") == 0) {
-		name = g_strdup (_("Smart Media Media"));
-	} else if (strcmp (drive->type, "sd_mmc") == 0) {
-		name = g_strdup (_("SD/MMC Media"));
-	} else if (strcmp (drive->type, "floppy") == 0) {
-		name = g_strdup (_("Floppy Disk"));
-	} else if (strcmp (drive->type, "disk") == 0) {
-
-		/* Look at the filesystem type, if applicable */
-		if (vol->fstype != NULL) {
-
-			    if (strcmp (vol->fstype, "hfs") == 0) {
-				    name = g_strdup (_("Mac OS disk"));
-			    } else if (strcmp (vol->fstype, "hfsplus") == 0) {
-				    name = g_strdup (_("Mac OS X disk"));
-			    } else if (strcmp (vol->fstype, "vfat") == 0 ||
-				strcmp (vol->fstype, "fat") == 0 ||
-				strcmp (vol->fstype, "msdos") == 0 ||
-				strcmp (vol->fstype, "msdosfs") == 0 ) {
-				    /* Many cameras and mp3 players use
-				     * FAT and we don't want the volume
-				     * icon to say "DOS Disk"; we'd rather
-				     * want the name of the device as fallback;
-				     * see below..
-				     */
-				    ;
-				    /*name = g_strdup (_("DOS Disk"));*/
-			    } else if (strcmp (vol->fstype, "ntfs") == 0) {
-				    name = g_strdup (_("Windows Disk"));
-			    } else if (strcmp (vol->fstype, "ext2") == 0 ||
-				       strcmp (vol->fstype, "ext3") == 0 ||
-				       strcmp (vol->fstype, "jfs") == 0 ||
-				       strcmp (vol->fstype, "xfs") == 0 ||
-				       strcmp (vol->fstype, "reiser") == 0) {
-				    name = g_strdup (_("Linux Disk"));
-			    }
-		}
-	}
-
-	/* fallback; use the same name as the drive */
-	if (name == NULL)
-		name = _hal_get_drive_name (NULL, drive, hal_ctx);
-
-	fixup_name (name);
+	{0x00, NULL}
+};
 
-	return name;
-}
 
-static char *
-_hal_get_vol_icon (GnomeVFSHalVolume *vol, GnomeVFSHalDrive *drive, 
-		   LibHalContext *hal_ctx)
+gboolean
+_gnome_vfs_hal_mounts_init (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon)
 {
-	char *icon;
-	char *category;
-
+	GnomeVFSHalUserData *hal_userdata;
+	HalStoragePolicy *hal_storage_policy;
 
-	category = hal_device_get_property_string (hal_ctx, 
-						   drive->physical_device,
-						   "info.category");
-	if (category != NULL) {
-		if (strcmp (category, "portable_audio_player") == 0) {
-			icon = g_strdup (HAL_ICON_PORTABLE_AUDIO_PLAYER);
-			return icon;
-		} else if (strcmp (category, "camera") == 0) {
-			icon = g_strdup (HAL_ICON_CAMERA);
-			return icon;
-		}
-	}
-
-
-	if (strcmp (drive->type, "cdrom") == 0) {
-
-		/* If it's a optical disc, use the disc type */
-		if (strcmp (vol->disc_type, "cd_rom") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_CDROM);
-		} else if (strcmp (vol->disc_type, "cd_r") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_CDR);
-		} else if (strcmp (vol->disc_type, "cd_rw") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_CDRW);
-		} else if (strcmp (vol->disc_type, "dvd_rom") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_DVDROM);
-		} else if (strcmp (vol->disc_type, "dvd_r") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_DVDR);
-		} else if (strcmp (vol->disc_type, "dvd_ram") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_DVDRAM);
-		} else if ((strcmp (vol->disc_type, "dvd_rw_restricted_overwrite") == 0) || (strcmp (vol->disc_type, "dvd_rw") == 0)) {
-			icon = g_strdup (HAL_ICON_DISC_DVDRW);
-		} else if (strcmp (vol->disc_type, "dvd_plus_rw") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_DVDRW_PLUS);
-		} else if (strcmp (vol->disc_type, "dvdplusr") == 0) {
-			icon = g_strdup (HAL_ICON_DISC_DVDR_PLUS);
-		} else {
-			icon = g_strdup (HAL_ICON_DISC_CDROM);
-		}
-
-	} else if (strcmp (drive->type, "floppy") == 0) {
-		icon = g_strdup (HAL_ICON_MEDIA_FLOPPY);
-	} else if (strcmp (drive->type, "compact_flash") == 0) {
-		icon = g_strdup (HAL_ICON_MEDIA_COMPACT_FLASH);
-	} else if (strcmp (drive->type, "memory_stick") == 0) {
-		icon = g_strdup (HAL_ICON_MEDIA_MEMORY_STICK);
-	} else if (strcmp (drive->type, "smart_media") == 0) {
-		icon = g_strdup (HAL_ICON_MEDIA_SMART_MEDIA);
-	} else if (strcmp (drive->type, "sd_mmc") == 0) {
-		icon = g_strdup (HAL_ICON_MEDIA_SD_MMC);
-	} else {
-
-		if (strcmp (drive->bus, "usb") == 0) {
-			icon = g_strdup (HAL_ICON_MEDIA_HARDDISK_USB);
-		} else if (strcmp (drive->bus, "ieee1394") == 0) {
-			icon = g_strdup (HAL_ICON_MEDIA_HARDDISK_IEEE1394);
-		} else {
-			icon = g_strdup (HAL_ICON_MEDIA_HARDDISK);
-		}
+	/* Initialise the connection to the hal daemon */
+	if ((volume_monitor_daemon->hal_ctx = 
+	     hal_initialize (&hal_functions, FALSE)) == NULL) {
+		g_warning ("hal_initialize failed\n");
+		return FALSE;
 	}
-	
-	return icon;
-}
-
-static int
-_hal_get_vol_type (GnomeVFSHalVolume *vol, GnomeVFSHalDrive *drive, 
-		   LibHalContext *hal_ctx)
-{
-	return _hal_get_drive_type (NULL, drive, hal_ctx);
-}
-
-/***********************************************************************/
 
-/** This function is used to skip certain volumes/drives we don't
- *  want to expose in GnomeVFS.
- *
- */
-static gboolean
-_hal_old_school_mount_point (GnomeVFSHalDrive *hal_drive, 
-			     GnomeVFSHalVolume *hal_vol,  /* may be NULL */
-			     char *mount_point)
-{
-	/* Skip standard UNIX-like mount points */
-	if (strcmp (mount_point, "/var") == 0 ||
-	    strcmp (mount_point, "/usr") == 0 ||
-	    strcmp (mount_point, "/bin") == 0 ||
-	    strcmp (mount_point, "/sbin") == 0 ||
-	    strcmp (mount_point, "/boot") == 0 ||
-	    strcmp (mount_point, "/tmp") == 0 ||
-	    strcmp (mount_point, "/opt") == 0 ||
-	    strcmp (mount_point, "/home") == 0 ||
-	    strcmp (mount_point, "/") == 0)
-		return TRUE;
 
-	return FALSE;
+	/* Setup GNOME specific policy - right now this is only icons */
+	hal_storage_policy = hal_storage_policy_new ();
+	hal_storage_policy_set_icon_mapping (hal_storage_policy, icon_mapping);
+
+	/* Tie some data with the libhal context */
+	hal_userdata = g_new0 (GnomeVFSHalUserData, 1);
+	hal_userdata->volume_monitor_daemon = volume_monitor_daemon;
+	hal_userdata->hal_storage_policy = hal_storage_policy;
+	hal_ctx_set_user_data (volume_monitor_daemon->hal_ctx,
+			       hal_userdata);
+	return TRUE;
 }
 
-/***********************************************************************/
-
-
-/* Add a drive where the media is not partition based.
- *
- *  It's safe to call this function multiple times for the same HAL 
- *  UDI (Unique Device Identifier).
- */
-static void 
-_hal_add_drive_no_partitions (
-	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon,
-	const char *udi)
+void
+_gnome_vfs_hal_mounts_shutdown (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon)
 {
-	GnomeVFSHalDrive *hal_drive = NULL;
-	LibHalContext *hal_ctx = volume_monitor_daemon->hal_ctx;
-	GnomeVFSDrive *drive;
-	GnomeVFSVolumeMonitor *volume_monitor = 
-		GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon);
-	char *name = NULL;
-	char *icon = NULL;
-	GnomeVFSDeviceType device_type = GNOME_VFS_DEVICE_TYPE_HARDDRIVE;
-	gboolean computer_visible = TRUE;
-	struct fstab *fst;
-	char *mount_point = NULL;
-
-#ifdef HAL_ONLY_SHOW_MOUNTED_VOLUMES
-	return;
-#endif
-
-	/*
-	 * We create the GnomeVFSDrive for such beasts since we can
-	 * actually do it in advance due to the fact that we already
-	 * know the device file and the mount point.
-	 */
-	
-	hal_drive = _hal_get_drive (udi, hal_ctx);
-	if (hal_drive == NULL)
-		goto out;
+	GnomeVFSHalUserData *hal_userdata;
 
-	/* get mount point from /etc/fstab */
-	if (setfsent () == 1) {
-		fst = getfsspec (hal_drive->device_file);
-		if (fst != NULL )
-			mount_point = strdup (fst->fs_file);
-		endfsent ();
-	}
-	if (mount_point == NULL || mount_point[0] != '/')
-		goto out;
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (volume_monitor_daemon->hal_ctx);
+	hal_storage_policy_free (hal_userdata->hal_storage_policy);
 
-	/* Include, but hide, drives with a hidden mount point */
-	if (_hal_old_school_mount_point (hal_drive, NULL, mount_point)) {
-		computer_visible = FALSE;
-	}
-	
-	/* see if drive was already added */
-	drive = _gnome_vfs_volume_monitor_find_drive_by_hal_udi (
-		volume_monitor, udi);
-	if (drive == NULL ) {
-
-		/* nope, make one */
-		
-		name = _hal_get_drive_name (NULL, hal_drive, hal_ctx);
-		icon = _hal_get_drive_icon (NULL, hal_drive, hal_ctx);
-		device_type = _hal_get_drive_type (NULL, hal_drive, hal_ctx);
-		
-		drive = g_object_new (GNOME_VFS_TYPE_DRIVE, NULL);
-		drive->priv->device_path = g_strdup (hal_drive->device_file);
-		
-		drive->priv->activation_uri = gnome_vfs_get_uri_from_local_path (mount_point);
-		drive->priv->is_connected = TRUE;
-		drive->priv->device_type = device_type;
-		drive->priv->icon = g_strdup (icon);
-		drive->priv->display_name = _gnome_vfs_volume_monitor_uniquify_drive_name (volume_monitor, name);
-		drive->priv->is_user_visible = computer_visible;
-		drive->priv->volumes = NULL;
-		drive->priv->hal_udi = g_strdup (udi);
-		
-		_gnome_vfs_volume_monitor_connected (volume_monitor, drive);
-		gnome_vfs_drive_unref (drive);
+	if (hal_shutdown (volume_monitor_daemon->hal_ctx) != 0) {
+		g_warning ("hal_shutdown failed\n");
 	}
-	
-out:
-	_hal_free_drive (hal_drive);
-	g_free (name);
-	g_free (icon);
-	free (mount_point);
 }
 
+/**************************************************************************/
 
-/* Add a hal-volume, that is, a HalDevice of capability 'volume'. 
+/** Ask HAL for more information about the drive and modify properties on the
+ *  GnomeVFSDrive as appropriate. Note that this happens before the object
+ *  is added to the volume monitor.
  *
- *  It's safe to call this function multiple times for the same HAL 
- *  UDI (Unique Device Identifier).
+ *  @param  volume_monitor_daemon  Handle to the volume monitor daemon
+ *  @param  drive                  Handle to the GnomeVFSDrive object
  */
-static void 
-_hal_add_volume (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon,
-		 const char *udi)
+void 
+_gnome_vfs_hal_mounts_modify_drive (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon, 
+				    GnomeVFSDrive *drive)
 {
-	GnomeVFSHalVolume *hal_vol = NULL;
-	GnomeVFSHalDrive *hal_drive = NULL;
-	LibHalContext *hal_ctx = volume_monitor_daemon->hal_ctx;
+	char *drive_name;
+	char *drive_icon;
+	char *unique_drive_name;
+	LibHalContext *hal_ctx; 
+	HalDrive *hal_drive;
+	HalVolume *hal_volume;
+	GnomeVFSHalUserData *hal_userdata;
+	HalStoragePolicy *hal_storage_policy;
+	char *target_mount_point;
 
-	GnomeVFSDrive *drive;
-	GnomeVFSVolume *vol;
-	GnomeVFSVolumeMonitor *volume_monitor = 
-		GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon);
-	char *name = NULL;
-	char *icon = NULL;
-	GnomeVFSDeviceType device_type = GNOME_VFS_DEVICE_TYPE_HARDDRIVE;
-	gboolean computer_visible = TRUE;
-	gboolean desktop_visible = FALSE;
-	struct fstab *fst;
-	char *mount_point = NULL;
-	gboolean is_blank_disc = FALSE;
-	gboolean is_audio_disc = FALSE;
-
-	/* Only care about capability volume */
-	if (!hal_device_query_capability (
-		    volume_monitor_daemon->hal_ctx,
-		    udi, "volume"))
-	{
+	hal_drive = NULL;
+	hal_volume = NULL;
 
-		/* And capability block where block.no_partition==TRUE and
-		 * block.is_volume==FALSE
-		 */
-		if (hal_device_query_capability (
-			    hal_ctx, udi, "block") &&
-		    (hal_device_get_property_bool (
-			    hal_ctx, udi, "block.no_partitions")==TRUE) &&
-		    (hal_device_get_property_bool (
-			    hal_ctx, udi, "block.is_volume")==FALSE)) {
-			/* This represent top-level block devices with
-			 * media not using partitions.. Such as floppy
-			 * drives or optical drives..
-			 */
-
-			_hal_add_drive_no_partitions (
-				volume_monitor_daemon, udi);
-			goto out;
-
-		} else {
-			/* Nothing we can use... */
-			goto out;
-		}
-	}
-
-
-	/* get HAL drive and volume objects */
-	hal_vol = _hal_get_vol (udi, hal_ctx);
-	if (hal_vol == NULL)
-		goto out;
-	hal_drive = _hal_get_drive_from_vol (hal_vol, hal_ctx);
-	if (hal_drive == NULL)
+	if ((hal_ctx = volume_monitor_daemon->hal_ctx) == NULL)
 		goto out;
 
-	/* See if we should have an icon on the desktop */
-	if (hal_drive->is_hotpluggable || 
-	    hal_vol->is_disc ||
-	    hal_drive->is_removable)
-		desktop_visible = TRUE;
-
-	/* If we are mounted, use the mount point that HAL knows */
-	if (hal_vol->is_mounted) {
-		mount_point = strdup (hal_vol->mount_point);
-	} else {
-		/* Otherwise... Yuck.. 
-		 *
-		 * gnome-vfs expects a mount point for a not yet
-		 * mounted volume which is kind of gross as it may be
-		 * mounted anywhere by e.g. root in the
-		 * future. Surely, this is not needed at all,
-		 * gnome-vfs should just be able to do a 'mount
-		 * /dev/sda1' or something.
-		 *
-		 * Now, HAL *could* monitor the /etc/fstab file and
-		 * maintain volume.mount_point property while
-		 * volume.is_mounted is FALSE, but this is unclean and
-		 * we really want the volume.mount_point to be empty
-		 * if, and only if, volume.is_mounted is FALSE.
-		 *
-		 * So, we just need to read the /etc/fstab here to
-		 * find the mount point (which is probably created by
-		 * a callout anyway). Oh well, piece of cake anyway..
-		 */
-		if (setfsent () == 1) {
-			fst = getfsspec (hal_vol->device_file);
-			if (fst != NULL )
-				mount_point = strdup (fst->fs_file);
-			endfsent ();
-		}
-	}
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	hal_storage_policy = hal_userdata->hal_storage_policy;
 
-	/* And we do need a mount point, and now we tried so hard to find
-	 * one.. bail out if we haven't got any.. 
-	 *
-	 * Further, getfspec above may return 'swap', so only accept a mount
-	 * point that starts with /. Hmmm..
-	 */
-	if (mount_point == NULL || mount_point[0]!='/')
+	if (drive == NULL || drive->priv == NULL || drive->priv->device_path == NULL)
 		goto out;
 
-	/* bail out if fstype is swap */
-	if (hal_vol->fstype != NULL && strcmp (hal_vol->fstype, "swap") == 0)
+	/* Note, the device_path may point to what hal calls a volume, e.g. 
+	 * /dev/sda1 etc, however we get the Drive object for the parent if
+	 * that is the case. This is a feature of libhal-storage.
+	 */
+	if ((hal_drive = hal_drive_from_device_file (hal_ctx, drive->priv->device_path)) == NULL) {
+		g_warning ("%s: no hal drive for device=%s", __FUNCTION__, drive->priv->device_path);
 		goto out;
-
-	/* see if we're a blank disc instead of being mounted */
-	is_blank_disc = hal_vol->is_disc && hal_vol->disc_is_blank;
-
-	/* see if we're a pure audio disc instead of being mounted */
-	is_audio_disc = hal_vol->is_disc && hal_vol->disc_has_audio &&
-		!hal_vol->disc_has_data;
-
-	/* Include, but hide, volumes with a hidden mount point */
-	if (_hal_old_school_mount_point (hal_drive, hal_vol, mount_point)) {
-		desktop_visible = FALSE;
-		computer_visible = FALSE;
 	}
 
-#ifdef HAL_ONLY_SHOW_MOUNTED_VOLUMES
-	/* we should also show blank discs */
-	if (!hal_vol->is_mounted && !is_blank_disc)
-		goto out;
-#endif
+	/* There may not be a volume object associated, so hal_volume may be NULL */
+	hal_volume = hal_volume_from_device_file (hal_ctx, drive->priv->device_path);
 
-	/* see if it was already added */
-	drive = _gnome_vfs_volume_monitor_find_drive_by_hal_udi (
-		volume_monitor, 
-#ifdef HAL_ONLY_SHOW_MOUNTED_VOLUMES
-			udi);
-#else
-			hal_drive->no_partitions ? hal_drive->udi : udi);
-#endif
-	if (drive == NULL ) {
-
-		/* nope, make one */
-
-		name = _hal_get_drive_name (hal_vol, hal_drive, hal_ctx);
-		icon = _hal_get_drive_icon (hal_vol, hal_drive, hal_ctx);
-		device_type = _hal_get_drive_type (hal_vol, hal_drive, hal_ctx);
-
-		drive = g_object_new (GNOME_VFS_TYPE_DRIVE, NULL);
-		drive->priv->device_path = g_strdup (hal_vol->device_file);
-
-		drive->priv->activation_uri = gnome_vfs_get_uri_from_local_path (mount_point);
-		drive->priv->is_connected = TRUE;
-		drive->priv->device_type = device_type;
-		drive->priv->icon = g_strdup (icon);
-		drive->priv->display_name = _gnome_vfs_volume_monitor_uniquify_drive_name (volume_monitor, name);
-		drive->priv->is_user_visible = computer_visible;
-		drive->priv->volumes = NULL;
-
-		drive->priv->hal_udi = g_strdup (
-#ifdef HAL_ONLY_SHOW_MOUNTED_VOLUMES
-			udi
-#else
-			hal_drive->no_partitions ? hal_drive->udi : udi
-#endif
-		);
-		_gnome_vfs_volume_monitor_connected (volume_monitor, drive);
-		gnome_vfs_drive_unref (drive);
-	} 
-
-	g_free (name); name = NULL;
-	g_free (icon); icon = NULL;
-
-	/* drive is now a reference to GnomeVFSDrive */
-
-	/* Only create a GnomeVFSVolume object if the volume is mounted 
-	 * or a blank disc */
-	if (hal_vol->is_mounted || is_blank_disc || is_audio_disc) {
-		/* see if hal_vol was already added */
-		vol = _gnome_vfs_volume_monitor_find_volume_by_hal_udi (
-			volume_monitor, udi);
-		if (vol == NULL ) {
-
-			name = _hal_get_vol_name (hal_vol, hal_drive, hal_ctx);
-			icon = _hal_get_vol_icon (hal_vol, hal_drive, hal_ctx);
-			device_type = _hal_get_vol_type (hal_vol, hal_drive, hal_ctx);
-
-			vol = g_object_new (GNOME_VFS_TYPE_VOLUME, NULL);
-			vol->priv->hal_udi = g_strdup (udi);
-			vol->priv->volume_type = GNOME_VFS_VOLUME_TYPE_MOUNTPOINT;
+	/* For optical discs, we manually add/remove GnomeVFSVolume optical discs without 
+	 * data (e.g. blank and pure audio) since these don't appear in the mounted filesystems
+	 * file /etc/mtab
+	 */
+	if (hal_volume != NULL && 
+	    hal_drive_get_type (hal_drive)==HAL_DRIVE_TYPE_CDROM && 
+	    hal_volume_is_disc (hal_volume) && !hal_volume_disc_has_data (hal_volume)) {
+		GnomeVFSVolume *volume;
+		char *volume_name;
+		char *volume_icon;
+
+		/* see if we already got a volume */
+		volume = _gnome_vfs_volume_monitor_find_volume_by_device_path (
+			GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon),
+			hal_drive_get_device_file (hal_drive));
+		if (volume == NULL) {
+
+			volume_name = hal_volume_policy_compute_display_name (
+				hal_drive, hal_volume, hal_storage_policy);
+
+			/* set icon name; try dedicated icon name first... */
+			if (hal_drive_get_dedicated_icon_volume (hal_drive) != NULL)
+				volume_icon = g_strdup (hal_drive_get_dedicated_icon_volume (hal_drive));
+			else
+				volume_icon = hal_volume_policy_compute_icon_name (
+					hal_drive, hal_volume, hal_storage_policy);
+
+			volume = g_object_new (GNOME_VFS_TYPE_VOLUME, NULL);
+			volume->priv->hal_udi = g_strdup (hal_volume_get_udi (hal_volume));
+			volume->priv->volume_type = GNOME_VFS_VOLUME_TYPE_MOUNTPOINT;
 			
-			if (is_blank_disc) {
-				vol->priv->device_path = g_strdup (hal_vol->device_file);
-				vol->priv->activation_uri = g_strdup ("burn:///");
-				vol->priv->unix_device = makedev (hal_vol->device_major, 
-								  hal_vol->device_minor);
-				vol->priv->filesystem_type = g_strdup (hal_vol->fstype);
-
-			} else if (is_audio_disc) {
-				vol->priv->device_path = g_strdup (hal_vol->device_file);
-				vol->priv->activation_uri = g_strdup_printf (
-					"cddb://%s", hal_vol->device_file);
-				vol->priv->unix_device = makedev (hal_vol->device_major, 
-								  hal_vol->device_minor);
-				vol->priv->filesystem_type = g_strdup (hal_vol->fstype);
-
-			} else {
-				vol->priv->device_path = g_strdup (hal_vol->device_file);
-				vol->priv->activation_uri = gnome_vfs_get_uri_from_local_path (mount_point);
-				vol->priv->unix_device = makedev (hal_vol->device_major, 
-								  hal_vol->device_minor);
-				vol->priv->filesystem_type = g_strdup (hal_vol->fstype);
+			if (hal_volume_disc_is_blank (hal_volume)) {
+				/* Blank discs should open the burn:/// location */
+				volume->priv->device_path = g_strdup (hal_volume_get_device_file (hal_volume));
+				volume->priv->activation_uri = g_strdup ("burn:///");
+				volume->priv->unix_device = makedev (hal_volume_get_device_major (hal_volume), 
+								     hal_volume_get_device_minor (hal_volume));
+				volume->priv->filesystem_type = g_strdup (hal_volume_get_fstype (hal_volume));
+			} else if (hal_volume_disc_has_audio (hal_volume)) {
+				/* Audio discs with data should open the cdda:///dev/cdrom location */
+				volume->priv->device_path = g_strdup (hal_volume_get_device_file (hal_volume));
+				volume->priv->activation_uri = g_strdup_printf (
+					"cdda://%s", hal_volume_get_device_file (hal_volume));
+				volume->priv->unix_device = makedev (hal_volume_get_device_major (hal_volume), 
+								     hal_volume_get_device_minor (hal_volume));
+				volume->priv->filesystem_type = g_strdup (hal_volume_get_fstype (hal_volume));
 			}
-
-			vol->priv->is_read_only = FALSE;
-			vol->priv->is_mounted = TRUE;
 			
-			vol->priv->device_type = device_type;
+			volume->priv->is_read_only = TRUE;
+			volume->priv->is_mounted = FALSE;
+			
+			volume->priv->device_type = GNOME_VFS_DEVICE_TYPE_CDROM;
 			
-			vol->priv->display_name = _gnome_vfs_volume_monitor_uniquify_volume_name (volume_monitor, name);
-			vol->priv->icon = g_strdup(icon);
-			vol->priv->is_user_visible = desktop_visible;
+			volume->priv->display_name = _gnome_vfs_volume_monitor_uniquify_volume_name (
+				GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), volume_name);
+			volume->priv->icon = g_strdup (volume_icon);
+			volume->priv->is_user_visible = TRUE;
 			
-			vol->priv->drive = drive;
-			_gnome_vfs_drive_add_mounted_volume (drive, vol);
+			volume->priv->drive = drive;
+			_gnome_vfs_drive_add_mounted_volume (drive, volume);
 			
-			_gnome_vfs_volume_monitor_mounted (volume_monitor, vol);			gnome_vfs_volume_unref (vol);
+			_gnome_vfs_volume_monitor_mounted (GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), volume);
+			gnome_vfs_volume_unref (volume);
 
+			free (volume_name);
+			free (volume_icon);
 		}
-	}
-
-out:
-	_hal_free_vol (hal_vol);
-	_hal_free_drive (hal_drive);
-	g_free (name);
-	g_free (icon);
-	free (mount_point);
-}
-
+	} else if (hal_volume == NULL && hal_drive_get_type (hal_drive)==HAL_DRIVE_TYPE_CDROM) {
+		GnomeVFSVolume *volume;
 
-/*  Remove a hal-volume, that is, a HalDevice of capability 'volume'. 
- *
- *  It's safe to call this function even though the hal-volume doesn't
- *  correspond to any (GnomeVFSDrive, GnomeVFSVolume) pair.
- */
-static void 
-_hal_remove_volume (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon,
-		    const char *udi)
-{
-	GnomeVFSDrive *drive;
-	GnomeVFSVolume *vol;
-	GnomeVFSVolumeMonitor *volume_monitor;
-
-	volume_monitor = GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon);
-
-	drive = _gnome_vfs_volume_monitor_find_drive_by_hal_udi (
-		volume_monitor, udi);
-	if (drive != NULL ) {
-		_gnome_vfs_volume_monitor_disconnected (volume_monitor, drive);
-	}
-
-	vol = _gnome_vfs_volume_monitor_find_volume_by_hal_udi (
-		volume_monitor, udi);
-	if (vol != NULL ) {
-		_gnome_vfs_volume_monitor_unmounted (volume_monitor, vol);
-	}
-}
-
-
-/*  Call when a HAL volume is unmounted.
- *
- *  It's safe to call this function even though the hal-volume doesn't
- *  correspond to GnomeVFSVolume object.
- */
-static void 
-_hal_volume_unmounted (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon,
-		       const char *udi)
-{
-	GnomeVFSVolume *vol;
-	GnomeVFSVolumeMonitor *volume_monitor;
-
-	volume_monitor = GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon);
-
-	vol = _gnome_vfs_volume_monitor_find_volume_by_hal_udi (
-		volume_monitor, udi);
-
-	if (vol != NULL ) {
-		_gnome_vfs_volume_monitor_unmounted (volume_monitor, vol);
-	}
-
-#ifdef HAL_ONLY_SHOW_MOUNTED_VOLUMES
-	{
-		GnomeVFSDrive *drive;
-		drive = _gnome_vfs_volume_monitor_find_drive_by_hal_udi (
-			volume_monitor, udi);
-		if (drive != NULL ) {
-			_gnome_vfs_volume_monitor_disconnected (volume_monitor, drive);
+		/* Remove GnomeVFSVolume with same device file */
+		
+		volume = _gnome_vfs_volume_monitor_find_volume_by_device_path (
+			GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), hal_drive_get_device_file (hal_drive));
+		if (volume != NULL) {
+			_gnome_vfs_volume_monitor_unmounted (GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), volume);
 		}
 	}
-#endif
 
-}
-
-
-void 
-_gnome_vfs_monitor_hal_get_volume_list (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon)
-{
-	int i;
-	int num_hal_volumes;
-	char **hal_volumes;
-	GnomeVFSVolumeMonitor *volume_monitor;
 
+	/* Now, modify the drive with the hal stuff, unless we've already done so */
+	if (drive->priv->hal_udi != NULL)
+		goto out;
 
-	volume_monitor = GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon);
-
-	hal_volumes = hal_find_device_by_capability (
-		volume_monitor_daemon->hal_ctx,
-		"volume",
-		&num_hal_volumes);
-	for (i=0; i<num_hal_volumes; i++) {
-		char *udi;
-
-		udi = hal_volumes [i];
+	/* set whether we need to eject */
+	drive->priv->should_eject = hal_drive_requires_eject (hal_drive);
 
-		_hal_add_volume (volume_monitor_daemon, udi);
+	/* set display name */
+	drive_name = hal_drive_policy_compute_display_name (hal_drive, hal_volume, hal_storage_policy);
+	unique_drive_name = _gnome_vfs_volume_monitor_uniquify_drive_name (
+		GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), drive_name);
+	if (drive->priv->display_name != NULL)
+		free (drive->priv->display_name);
+	drive->priv->display_name = unique_drive_name;
+	free (drive_name);
+
+	/* set icon name; try dedicated icon name first... */
+	if (hal_drive_get_dedicated_icon_drive (hal_drive) != NULL)
+		drive_icon = g_strdup (hal_drive_get_dedicated_icon_drive (hal_drive));
+	else
+		drive_icon = hal_drive_policy_compute_icon_name (hal_drive, hal_volume, hal_storage_policy);
+	if (drive->priv->icon != NULL)
+		free (drive->priv->icon);
+	drive->priv->icon = g_strdup (drive_icon);
+	free (drive_icon);
+
+	/* figure out target mount point; first see if we're mounted */
+	target_mount_point = NULL;
+	if (hal_volume != NULL) {
+		const char *str;
+		str = hal_volume_get_mount_point (hal_volume);
+		if (str != NULL)
+			target_mount_point = g_strdup (str);
+	}
+
+	/* otherwise lookup fstab */
+	if (target_mount_point == NULL && setfsent () == 1) {
+		struct fstab *fst;
+		fst = getfsspec (drive->priv->device_path);
+		if (fst != NULL )
+			target_mount_point = g_strdup (fst->fs_file);
+		endfsent ();
 	}
-	hal_free_string_array (hal_volumes);
-
-	hal_volumes = hal_find_device_by_capability (
-		volume_monitor_daemon->hal_ctx,
-		"block",
-		&num_hal_volumes);
-	for (i=0; i<num_hal_volumes; i++) {
-		char *udi;
 
-		udi = hal_volumes [i];
+	/* if we don't use removable media and the volume shouldn't be visible, then hide the drive */
+	if(!hal_drive_uses_removable_media (hal_drive) && 
+	   !hal_volume_policy_should_be_visible (hal_drive, hal_volume, hal_storage_policy, target_mount_point))
+		drive->priv->is_user_visible = FALSE;
 
-		_hal_add_volume (volume_monitor_daemon, udi);
-	}
-	hal_free_string_array (hal_volumes);
-}
-
-static void
-_hal_mainloop_integration (LibHalContext *ctx, 
-			   DBusConnection * dbus_connection)
-{
-        dbus_connection_setup_with_g_main (dbus_connection, NULL);
-}
+	g_free (target_mount_point);
 
-static void 
-_hal_device_added (LibHalContext *ctx, 
-		   const char *udi)
-{
-	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
-	volume_monitor_daemon = (GnomeVFSVolumeMonitorDaemon *)
-		hal_ctx_get_user_data (ctx);
-	_hal_add_volume (volume_monitor_daemon, udi);
-}
+	/* set hal udi */
+	drive->priv->hal_udi = g_strdup (hal_drive_get_udi (hal_drive));
 
-static void 
-_hal_device_removed (LibHalContext *ctx, 
-		     const char *udi)
-{
-	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
-	volume_monitor_daemon = (GnomeVFSVolumeMonitorDaemon *)
-		hal_ctx_get_user_data (ctx);
-	_hal_remove_volume (volume_monitor_daemon, udi);
+out:
+	hal_volume_free (hal_volume);
+	hal_drive_free (hal_drive);
 }
 
-static void 
-_hal_device_new_capability (LibHalContext *ctx, 
-			    const char *udi, 
-			    const char *capability)
+void 
+_gnome_vfs_hal_mounts_modify_volume (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon, 
+				     GnomeVFSVolume *volume)
 {
-	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
-	volume_monitor_daemon = (GnomeVFSVolumeMonitorDaemon *)
-		hal_ctx_get_user_data (ctx);
-	_hal_add_volume (volume_monitor_daemon, udi);
-}
+	char *volume_name;
+	char *volume_icon;
+	char *unique_volume_name;
+	LibHalContext *hal_ctx; 
+	HalDrive *hal_drive;
+	HalVolume *hal_volume;
+	GnomeVFSHalUserData *hal_userdata;
+	HalStoragePolicy *hal_storage_policy;
+	char *target_mount_point;
 
-static void 
-_hal_device_lost_capability (LibHalContext *ctx, 
-			     const char *udi,
-			     const char *capability)
-{
-}
+	hal_volume = NULL;
+	hal_drive = NULL;
 
-static void 
-_hal_device_property_modified (LibHalContext *ctx, 
-			       const char *udi,
-			       const char *key,
-			       dbus_bool_t is_removed,
-			       dbus_bool_t is_added)
-{
-	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
-	volume_monitor_daemon = (GnomeVFSVolumeMonitorDaemon *)
-		hal_ctx_get_user_data (ctx);
+	if ((hal_ctx = volume_monitor_daemon->hal_ctx) == NULL)
+		goto out;
+	if (volume == NULL || volume->priv == NULL || volume->priv->device_path == NULL)
+		goto out;
 
-	if (!is_removed && strcmp (key, "volume.is_mounted") == 0) {
-		dbus_bool_t is_mounted;
+	hal_userdata = (GnomeVFSHalUserData *) hal_ctx_get_user_data (hal_ctx);
+	hal_storage_policy = hal_userdata->hal_storage_policy;
 
-		is_mounted = hal_device_get_property_bool(
-			ctx, udi, "volume.is_mounted");
+	/* Now, modify the drive with the hal stuff, unless we've already done so */
+	if (volume->priv->hal_udi != NULL)
+		goto out;
 
-		if( is_mounted )
-			_hal_add_volume (volume_monitor_daemon, udi);
-		else
-			_hal_volume_unmounted (volume_monitor_daemon, udi);
+	/* Note, the device_path points to what hal calls a volume, e.g. 
+	 * /dev/sda1 etc, however we get the Drive object for the parent if
+	 * that is the case. This is a feature of libhal-storage.
+	 */
+	if ((hal_drive = hal_drive_from_device_file (hal_ctx, volume->priv->device_path)) == NULL) {
+		g_warning ("%s: no hal drive for device=%s", __FUNCTION__, volume->priv->device_path);
+		goto out;
 	}
-}
-
-static void 
-_hal_device_condition (LibHalContext *ctx, 
-		       const char *udi,
-		       const char *condition_name,
-		       DBusMessage *message)
-{
-	GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon;
-	volume_monitor_daemon = (GnomeVFSVolumeMonitorDaemon *)
-		hal_ctx_get_user_data (ctx);
-
-	if (strcmp (condition_name, "BlockForcedUnmountPartition") == 0) {
-		_hal_remove_volume (volume_monitor_daemon, udi);
+	if ((hal_volume = hal_volume_from_device_file (hal_ctx, volume->priv->device_path)) == NULL) {
+		g_warning ("%s: no hal volume for device=%s", __FUNCTION__, volume->priv->device_path);
+		goto out;
 	}
-}
 
-static LibHalFunctions
-hal_functions = { _hal_mainloop_integration,
-		  _hal_device_added,
-		  _hal_device_removed,
-		  _hal_device_new_capability,
-		  _hal_device_lost_capability,
-		  _hal_device_property_modified,
-		  _hal_device_condition };
+	/* set display name */
+	volume_name = hal_volume_policy_compute_display_name (hal_drive, hal_volume, hal_storage_policy);
+	unique_volume_name = _gnome_vfs_volume_monitor_uniquify_volume_name (
+		GNOME_VFS_VOLUME_MONITOR (volume_monitor_daemon), volume_name);
+	if (volume->priv->display_name != NULL)
+		free (volume->priv->display_name);
+	volume->priv->display_name = unique_volume_name;
+	free (volume_name);
+
+	/* set icon name; try dedicated icon name first... */
+	if (hal_drive_get_dedicated_icon_volume (hal_drive) != NULL)
+		volume_icon = g_strdup (hal_drive_get_dedicated_icon_volume (hal_drive));
+	else
+		volume_icon = hal_volume_policy_compute_icon_name (hal_drive, hal_volume, hal_storage_policy);
+	if (volume->priv->icon != NULL)
+		free (volume->priv->icon);
+	volume->priv->icon = g_strdup (volume_icon);
+	free (volume_icon);
 
-gboolean
-_gnome_vfs_monitor_hal_mounts_init (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon)
-{
-	/* initialise the connection to the hal daemon */
-	if ((volume_monitor_daemon->hal_ctx = 
-	     hal_initialize (&hal_functions, FALSE)) == NULL) {
-		g_warning ("hal_initialize failed\n");
-		return FALSE;
+	/* figure out target mount point; first see if we're mounted */
+	target_mount_point = NULL;
+	{
+		const char *str;
+		str = hal_volume_get_mount_point (hal_volume);
+		if (str != NULL)
+			target_mount_point = g_strdup (str);
 	}
 
-	hal_ctx_set_user_data (volume_monitor_daemon->hal_ctx,
-			       volume_monitor_daemon);
+	/* otherwise lookup fstab */
+	if (target_mount_point == NULL && setfsent () == 1) {
+		struct fstab *fst;
+		fst = getfsspec (volume->priv->device_path);
+		if (fst != NULL )
+			target_mount_point = g_strdup (fst->fs_file);
+		endfsent ();
+	}
 
-	hal_device_property_watch_all (volume_monitor_daemon->hal_ctx);
+	/* set whether it's visible on the desktop */
+	volume->priv->is_user_visible = 
+		hal_volume_policy_should_be_visible (hal_drive, hal_volume, hal_storage_policy, target_mount_point) &&
+		(hal_drive_is_hotpluggable (hal_drive) || hal_drive_uses_removable_media (hal_drive));
 
-	return TRUE;
-}
+	g_free (target_mount_point);
 
-void
-_gnome_vfs_monitor_hal_mounts_shutdown (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon)
-{
-	if (hal_shutdown (volume_monitor_daemon->hal_ctx) != 0) {
-		g_warning ("hal_shutdown failed\n");
-	}
+	/* set hal udi */
+	volume->priv->hal_udi = g_strdup (hal_volume_get_udi (hal_volume));
+out:
+	hal_drive_free (hal_drive);
+	hal_volume_free (hal_volume);
 }
 
 #endif /* USE_HAL */
Index: libgnomevfs/gnome-vfs-hal-mounts.h
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-hal-mounts.h,v
retrieving revision 1.3
diff -u -p -r1.3 gnome-vfs-hal-mounts.h
--- libgnomevfs/gnome-vfs-hal-mounts.h	19 Aug 2004 07:34:01 -0000	1.3
+++ libgnomevfs/gnome-vfs-hal-mounts.h	24 Sep 2004 22:50:34 -0000
@@ -1,7 +1,7 @@
 /* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
 /* gnome-vfs-hal-mounts.h - read and monitor volumes using freedesktop HAL
 
-   Copyright (C) 2004 David Zeuthen
+   Copyright (C) 2004 Red Hat, Inc.
 
    The Gnome Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public License as
@@ -18,7 +18,7 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
 
-   Author: David Zeuthen <david@fubar.dk>
+   Author: David Zeuthen <davidz@redhat.com>
 */
 
 #ifndef GNOME_VFS_HAL_MOUNTS_H
@@ -26,12 +26,14 @@
 
 #include "gnome-vfs-volume-monitor-daemon.h"
 
-gboolean _gnome_vfs_monitor_hal_mounts_init (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon);
+gboolean _gnome_vfs_hal_mounts_init (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon);
 
-void _gnome_vfs_monitor_hal_mounts_shutdown (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon);
-
-void _gnome_vfs_monitor_hal_get_volume_list (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon);
+void _gnome_vfs_hal_mounts_shutdown (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon);
 
+void _gnome_vfs_hal_mounts_modify_drive (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon, 
+					 GnomeVFSDrive *drive);
+void _gnome_vfs_hal_mounts_modify_volume (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon, 
+					  GnomeVFSVolume *volume);
 
 
 #endif /* GNOME_VFS_HAL_MOUNTS_H */
Index: libgnomevfs/gnome-vfs-volume-monitor-daemon.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-volume-monitor-daemon.c,v
retrieving revision 1.15
diff -u -p -r1.15 gnome-vfs-volume-monitor-daemon.c
--- libgnomevfs/gnome-vfs-volume-monitor-daemon.c	22 Sep 2004 08:38:38 -0000	1.15
+++ libgnomevfs/gnome-vfs-volume-monitor-daemon.c	24 Sep 2004 22:50:34 -0000
@@ -154,7 +154,7 @@ static void
 gnome_vfs_volume_monitor_daemon_init (GnomeVFSVolumeMonitorDaemon *volume_monitor_daemon)
 {
 #ifdef USE_HAL
-	if (_gnome_vfs_monitor_hal_mounts_init (volume_monitor_daemon)) {
+	if (_gnome_vfs_hal_mounts_init (volume_monitor_daemon)) {
 		/* It worked, do use HAL */
 		dont_use_hald = FALSE;
 	} else {
@@ -163,12 +163,10 @@ gnome_vfs_volume_monitor_daemon_init (Gn
 	}
 #endif /* USE_HAL */
 
-	if (dont_use_hald) {
-		_gnome_vfs_monitor_unix_mounts (fstab_changed,
-						volume_monitor_daemon,
-						mtab_changed,
-						volume_monitor_daemon);
-	}
+	_gnome_vfs_monitor_unix_mounts (fstab_changed,
+					volume_monitor_daemon,
+					mtab_changed,
+					volume_monitor_daemon);
 
 	volume_monitor_daemon->gconf_client = gconf_client_get_default ();
 	gconf_client_add_dir (volume_monitor_daemon->gconf_client,
@@ -185,16 +183,8 @@ gnome_vfs_volume_monitor_daemon_init (Gn
 					 NULL);
 								       
 	
-	if (dont_use_hald) {
-		update_fstab_drives (volume_monitor_daemon);
-		update_mtab_volumes (volume_monitor_daemon);
-	}
-#ifdef USE_HAL
-	else {
-		_gnome_vfs_monitor_hal_get_volume_list (volume_monitor_daemon);
-	}
-#endif /* USE_HAL */
-
+	update_fstab_drives (volume_monitor_daemon);
+	update_mtab_volumes (volume_monitor_daemon);
 	update_connected_servers (volume_monitor_daemon);
 }
 
@@ -205,15 +195,8 @@ gnome_vfs_volume_monitor_daemon_force_pr
 	
 	volume_monitor_daemon = GNOME_VFS_VOLUME_MONITOR_DAEMON (volume_monitor);
 	
-	if (dont_use_hald) {
-		update_fstab_drives (volume_monitor_daemon);
-		update_mtab_volumes (volume_monitor_daemon);
-	}
-#ifdef USE_HAL
-	else {
-		_gnome_vfs_monitor_hal_get_volume_list (volume_monitor_daemon);
-	}
-#endif /* USE_HAL */
+	update_fstab_drives (volume_monitor_daemon);
+	update_mtab_volumes (volume_monitor_daemon);
 	update_connected_servers (volume_monitor_daemon);
 }
 
@@ -226,22 +209,15 @@ gnome_vfs_volume_monitor_daemon_finalize
 
 	volume_monitor_daemon = GNOME_VFS_VOLUME_MONITOR_DAEMON (object);
 		
-	if (dont_use_hald) {
-		_gnome_vfs_stop_monitoring_unix_mounts ();
+	_gnome_vfs_stop_monitoring_unix_mounts ();
 
-		g_list_foreach (volume_monitor_daemon->last_mtab,
-				(GFunc)_gnome_vfs_unix_mount_free, NULL);
-		g_list_free (volume_monitor_daemon->last_mtab);
-	
-		g_list_foreach (volume_monitor_daemon->last_fstab,
-				(GFunc)_gnome_vfs_unix_mount_point_free, NULL);
-		g_list_free (volume_monitor_daemon->last_fstab);	
-	}
-#ifdef USE_HAL
-	else {
-		_gnome_vfs_monitor_hal_mounts_shutdown (volume_monitor_daemon);
-	}
-#endif /* USE_HAL */
+	g_list_foreach (volume_monitor_daemon->last_mtab,
+			(GFunc)_gnome_vfs_unix_mount_free, NULL);
+	g_list_free (volume_monitor_daemon->last_mtab);
+	
+	g_list_foreach (volume_monitor_daemon->last_fstab,
+			(GFunc)_gnome_vfs_unix_mount_point_free, NULL);
+	g_list_free (volume_monitor_daemon->last_fstab);	
 
 	gconf_client_notify_remove (volume_monitor_daemon->gconf_client,
 				    volume_monitor_daemon->connected_id);
@@ -755,12 +731,19 @@ update_fstab_drives (GnomeVFSVolumeMonit
 			mount = l->data;
 		
 			drive = create_drive_from_mount_point (volume_monitor, mount);
+
 			if (drive != NULL) {
+
+#ifdef USE_HAL
+				if (!dont_use_hald)
+					_gnome_vfs_hal_mounts_modify_drive (volume_monitor_daemon, drive);
+#endif /* USE_HAL */
+					
 				_gnome_vfs_volume_monitor_connected (volume_monitor, drive);
 				gnome_vfs_drive_unref (drive);
 			}
 		}
-		
+
 		g_list_free (added);
 		g_list_free (removed);
 		g_list_foreach (volume_monitor_daemon->last_fstab,
@@ -1021,6 +1004,10 @@ update_mtab_volumes (GnomeVFSVolumeMonit
 		
 			vol = create_vol_from_mount (volume_monitor, mount);
 			vol->priv->unix_device = unix_device;
+#ifdef USE_HAL
+			if (!dont_use_hald)
+				_gnome_vfs_hal_mounts_modify_volume (volume_monitor_daemon, vol);
+#endif /* USE_HAL */
 			_gnome_vfs_volume_monitor_mounted (volume_monitor, vol);
 			gnome_vfs_volume_unref (vol);
 		}
@@ -1033,8 +1020,6 @@ update_mtab_volumes (GnomeVFSVolumeMonit
 		g_list_free (volume_monitor_daemon->last_mtab);
 		volume_monitor_daemon->last_mtab = new_mtab;
 	}
-
-	
 }
 
 /************************* connected server ***********************************/
Index: libgnomevfs/gnome-vfs-volume-monitor-private.h
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-volume-monitor-private.h,v
retrieving revision 1.7
diff -u -p -r1.7 gnome-vfs-volume-monitor-private.h
--- libgnomevfs/gnome-vfs-volume-monitor-private.h	15 Jul 2004 13:21:15 -0000	1.7
+++ libgnomevfs/gnome-vfs-volume-monitor-private.h	24 Sep 2004 22:50:34 -0000
@@ -85,6 +85,8 @@ struct _GnomeVFSDrivePrivate {
 
 	/* Only for HAL devices: */
 	char *hal_udi;
+
+	gboolean should_eject;
 };
 
 void _gnome_vfs_volume_set_drive                (GnomeVFSVolume        *volume,
@@ -132,11 +134,17 @@ GnomeVFSVolume *_gnome_vfs_volume_monito
 
 #ifdef USE_HAL
 GnomeVFSVolume *_gnome_vfs_volume_monitor_find_volume_by_hal_udi (GnomeVFSVolumeMonitor *volume_monitor,
-								  const char *hal_udi);
-GnomeVFSDrive *_gnome_vfs_volume_monitor_find_drive_by_hal_udi (GnomeVFSVolumeMonitor *volume_monitor,
-								const char           *hal_udi);
+								  const char            *hal_udi);
+GnomeVFSDrive *_gnome_vfs_volume_monitor_find_drive_by_hal_udi   (GnomeVFSVolumeMonitor *volume_monitor,
+								  const char            *hal_udi);
 
 #endif /* USE_HAL */
+
+GnomeVFSVolume *_gnome_vfs_volume_monitor_find_volume_by_device_path (GnomeVFSVolumeMonitor *volume_monitor,
+								      const char            *device_path);
+GnomeVFSDrive *_gnome_vfs_volume_monitor_find_drive_by_device_path   (GnomeVFSVolumeMonitor *volume_monitor,
+								      const char            *device_path);
+
 
 
 char *_gnome_vfs_volume_monitor_uniquify_volume_name (GnomeVFSVolumeMonitor *volume_monitor,
Index: libgnomevfs/gnome-vfs-volume-monitor.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-volume-monitor.c,v
retrieving revision 1.9
diff -u -p -r1.9 gnome-vfs-volume-monitor.c
--- libgnomevfs/gnome-vfs-volume-monitor.c	16 Sep 2004 18:17:27 -0000	1.9
+++ libgnomevfs/gnome-vfs-volume-monitor.c	24 Sep 2004 22:50:35 -0000
@@ -344,6 +344,52 @@ _gnome_vfs_volume_monitor_find_drive_by_
 }
 #endif /* USE_HAL */
 
+GnomeVFSVolume *
+_gnome_vfs_volume_monitor_find_volume_by_device_path (GnomeVFSVolumeMonitor *volume_monitor,
+						      const char *device_path)
+{
+	GList *l;
+	GnomeVFSVolume *vol, *ret;
+
+	/* Doesn't need locks, only called internally on main thread and doesn't write */
+	
+	ret = NULL;
+	for (l = volume_monitor->priv->mtab_volumes; l != NULL; l = l->next) {
+		vol = l->data;
+		if (vol->priv != NULL && vol->priv->hal_udi != NULL && 
+		    vol->priv->device_path != NULL && /* Hmm */
+		    strcmp (vol->priv->device_path, device_path) == 0) {
+			ret = vol;
+			break;
+		}
+	}
+	
+	return ret;
+}
+
+GnomeVFSDrive *
+_gnome_vfs_volume_monitor_find_drive_by_device_path (GnomeVFSVolumeMonitor *volume_monitor,
+						     const char *device_path)
+{
+	GList *l;
+	GnomeVFSDrive *drive, *ret;
+
+	/* Doesn't need locks, only called internally on main thread and doesn't write */
+	
+	ret = NULL;
+	for (l = volume_monitor->priv->fstab_drives; l != NULL; l = l->next) {
+		drive = l->data;
+		if (drive->priv != NULL && drive->priv->hal_udi != NULL &&
+		    drive->priv->device_path != NULL && /* Hmm */
+		    strcmp (drive->priv->device_path, device_path) == 0) {
+			ret = drive;
+			break;
+		}
+	}
+
+	return ret;
+}
+
 
 GnomeVFSVolume *
 _gnome_vfs_volume_monitor_find_mtab_volume_by_activation_uri (GnomeVFSVolumeMonitor *volume_monitor,
Index: libgnomevfs/gnome-vfs-volume-ops.c
===================================================================
RCS file: /cvs/gnome/gnome-vfs/libgnomevfs/gnome-vfs-volume-ops.c,v
retrieving revision 1.14
diff -u -p -r1.14 gnome-vfs-volume-ops.c
--- libgnomevfs/gnome-vfs-volume-ops.c	16 Aug 2004 08:44:06 -0000	1.14
+++ libgnomevfs/gnome-vfs-volume-ops.c	24 Sep 2004 22:50:35 -0000
@@ -331,15 +331,19 @@ mount_unmount_operation (const char *mou
 	int i;
 
 	
-#ifdef USE_VOLRMMOUNT
-       name = strrchr (mount_point, '/');
-       if (name != NULL) {
-               name = name + 1;
-       } else {
-	       name = mount_point;
-       }
+#ifdef __linux__
+	name = device_path;
 #else
+# ifdef USE_VOLRMMOUNT
+	name = strrchr (mount_point, '/');
+        if (name != NULL) {
+                name = name + 1;
+        } else {
+		name = mount_point;
+        }
+# else
        name = mount_point;
+# endif
 #endif
        
        if (should_mount) {
@@ -501,7 +505,14 @@ gnome_vfs_volume_unmount (GnomeVFSVolume
 	char *mount_path, *device_path;
 	char *uri;
 	GnomeVFSVolumeType type;
-	
+
+	if (volume->priv->drive != NULL) {
+		if (volume->priv->drive->priv->should_eject) {
+			gnome_vfs_volume_eject (volume, callback, user_data);
+			return;
+		}
+	}
+
 	emit_pre_unmount (volume);
 
 	type = gnome_vfs_volume_get_volume_type (volume);
@@ -608,6 +619,11 @@ gnome_vfs_drive_unmount (GnomeVFSDrive  
 {
 	GList *vol_list;
 	GList *current_vol;
+
+	if (drive->priv->should_eject) {
+		gnome_vfs_drive_eject(drive, callback, user_data);
+		return;
+	}
 
 	vol_list = gnome_vfs_drive_get_mounted_volumes (drive);
 
